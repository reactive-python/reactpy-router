{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ReactPy Router","text":"<p>A URL router for ReactPy.</p> <p>Note</p> <p>If you don't already know the basics of working with ReactPy, you should start there.</p>"},{"location":"#installation","title":"Installation","text":"<p>Use <code>pip</code> to install this package:</p> <pre><code>pip install reactpy-router\n</code></pre> <p>installer.records</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Note</p> <p>The Code of Conduct applies in all community spaces. If you are not familiar with our Code of Conduct policy, take a minute to read it before making your first contribution.</p> <p>The ReactPy team welcomes contributions and contributors of all kinds - whether they come as code changes, participation in the discussions, opening issues and pointing out bugs, or simply sharing your work with your colleagues and friends. We\u2019re excited to see how you can help move this project and community forward!</p>"},{"location":"contributing/#everyone-can-contribute","title":"Everyone Can Contribute!","text":"<p>Trust us, there\u2019s so many ways to support the project. We\u2019re always looking for people who can:</p> <ul> <li>Improve our documentation</li> <li>Teach and tell others about ReactPy</li> <li>Share ideas for new features</li> <li>Report bugs</li> <li>Participate in general discussions</li> </ul> <p>Still aren\u2019t sure what you have to offer? Just ask us and we\u2019ll help you make your first contribution.</p>"},{"location":"contributing/#development-environment","title":"Development Environment","text":"<p>For a developer installation from source be sure to install NPM before running:</p> <pre><code>git clone https://github.com/reactive-python/reactpy-router\ncd reactpy-router\npip install -e . -r requirements.txt\n</code></pre> <p>This will install an ediable version of <code>reactpy-router</code> as well as tools you'll need to work with this project.</p> <p>Of particular note is <code>nox</code>, which is used to automate testing and other development tasks.</p>"},{"location":"contributing/#running-the-tests","title":"Running the Tests","text":"<pre><code>nox -t test\n</code></pre> <p>You can run the tests with a headed browser.</p> <pre><code>nox -t test -- --headed\n</code></pre>"},{"location":"contributing/#releasing-this-package","title":"Releasing This Package","text":"<p>To release a new version of reactpy-router on PyPI:</p> <ol> <li>Install <code>twine</code> with <code>pip install twine</code></li> <li>Update the <code>version = \"x.y.z\"</code> variable in <code>reactpy-router/__init__.py</code></li> <li><code>git</code> add the changes to <code>__init__.py</code> and create a <code>git tag -a x.y.z -m 'comment'</code></li> <li>Build the Python package with <code>python setup.py sdist bdist_wheel</code></li> <li>Check the build artifacts <code>twine check --strict dist/*</code></li> <li>Upload the build artifacts to PyPI <code>twine upload dist/*</code></li> </ol> <p>To release a new version of <code>reactpy-router</code> on NPM:</p> <ol> <li>Update <code>js/package.json</code> with new npm package version</li> <li>Clean out prior builds <code>git clean -fdx</code></li> <li>Install and publish <code>npm install &amp;&amp; npm publish</code></li> </ol>"},{"location":"reference/","title":"Reference","text":"<p>Core functionality for the reactpy-router package.</p> <p>A simple router implementation for ReactPy</p> <p>Types for reactpy_router</p>"},{"location":"reference/#reactpy_router.core.create_router","title":"<code>create_router(compiler)</code>","text":"<p>A decorator that turns a route compiler into a router</p> Source code in <code>reactpy_router/core.py</code> <pre><code>def create_router(compiler: RouteCompiler[R]) -&gt; Router[R]:\n\"\"\"A decorator that turns a route compiler into a router\"\"\"\n\n    def wrapper(*routes: R) -&gt; ComponentType:\n        return router_component(*routes, compiler=compiler)\n\n    return wrapper\n</code></pre>"},{"location":"reference/#reactpy_router.core.link","title":"<code>link(*children, to, **attributes)</code>","text":"<p>A component that renders a link to the given path</p> Source code in <code>reactpy_router/core.py</code> <pre><code>@component\ndef link(*children: VdomChild, to: str, **attributes: Any) -&gt; VdomDict:\n\"\"\"A component that renders a link to the given path\"\"\"\n    set_location = _use_route_state().set_location\n    attrs = {\n        **attributes,\n        \"to\": to,\n        \"onClick\": lambda event: set_location(Location(**event)),\n    }\n    return _link(attrs, *children)\n</code></pre>"},{"location":"reference/#reactpy_router.core.route","title":"<code>route(path, element, *routes)</code>","text":"<p>Create a route with the given path, element, and child routes</p> Source code in <code>reactpy_router/core.py</code> <pre><code>def route(path: str, element: Any | None, *routes: Route) -&gt; Route:\n\"\"\"Create a route with the given path, element, and child routes\"\"\"\n    return Route(path, element, routes)\n</code></pre>"},{"location":"reference/#reactpy_router.core.router_component","title":"<code>router_component(*routes, compiler)</code>","text":"<p>A component that renders the first matching route using the given compiler</p> Source code in <code>reactpy_router/core.py</code> <pre><code>@component\ndef router_component(\n    *routes: R,\n    compiler: RouteCompiler[R],\n) -&gt; VdomDict | None:\n\"\"\"A component that renders the first matching route using the given compiler\"\"\"\n\n    old_conn = use_connection()\n    location, set_location = use_state(old_conn.location)\n\n    resolvers = use_memo(\n        lambda: tuple(map(compiler, _iter_routes(routes))),\n        dependencies=(compiler, hash(routes)),\n    )\n\n    match = use_memo(lambda: _match_route(resolvers, location))\n\n    if match is not None:\n        element, params = match\n        return html._(\n            ConnectionContext(\n                _route_state_context(element, value=_RouteState(set_location, params)),\n                value=Connection(old_conn.scope, location, old_conn.carrier),\n            ),\n            _history({\"on_change\": lambda event: set_location(Location(**event))}),\n        )\n\n    return None\n</code></pre>"},{"location":"reference/#reactpy_router.core.use_params","title":"<code>use_params()</code>","text":"<p>Get parameters from the currently matching route pattern</p> Source code in <code>reactpy_router/core.py</code> <pre><code>def use_params() -&gt; dict[str, Any]:\n\"\"\"Get parameters from the currently matching route pattern\"\"\"\n    return _use_route_state().params\n</code></pre>"},{"location":"reference/#reactpy_router.core.use_query","title":"<code>use_query(keep_blank_values=False, strict_parsing=False, errors='replace', max_num_fields=None, separator='&amp;')</code>","text":"<p>See :func:<code>urllib.parse.parse_qs</code> for parameter info.</p> Source code in <code>reactpy_router/core.py</code> <pre><code>def use_query(\n    keep_blank_values: bool = False,\n    strict_parsing: bool = False,\n    errors: str = \"replace\",\n    max_num_fields: int | None = None,\n    separator: str = \"&amp;\",\n) -&gt; dict[str, list[str]]:\n\"\"\"See :func:`urllib.parse.parse_qs` for parameter info.\"\"\"\n    return parse_qs(\n        use_location().search[1:],\n        keep_blank_values=keep_blank_values,\n        strict_parsing=strict_parsing,\n        errors=errors,\n        max_num_fields=max_num_fields,\n        separator=separator,\n    )\n</code></pre>"},{"location":"reference/#reactpy_router.simple.CONVERSION_TYPES","title":"<code>CONVERSION_TYPES: dict[str, ConversionInfo] = {'str': {'regex': '[^/]+', 'func': str}, 'int': {'regex': '\\\\d+', 'func': int}, 'float': {'regex': '\\\\d+(\\\\.\\\\d+)?', 'func': float}, 'uuid': {'regex': '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}', 'func': uuid.UUID}, 'path': {'regex': '.+', 'func': str}}</code>  <code>module-attribute</code>","text":"<p>The supported conversion types</p>"},{"location":"reference/#reactpy_router.simple.router","title":"<code>router = create_router(SimpleResolver)</code>  <code>module-attribute</code>","text":"<p>The simple router</p>"},{"location":"reference/#reactpy_router.simple.ConversionInfo","title":"<code>ConversionInfo</code>","text":"<p>             Bases: <code>TypedDict</code></p> <p>Information about a conversion type</p> Source code in <code>reactpy_router/simple.py</code> <pre><code>class ConversionInfo(TypedDict):\n\"\"\"Information about a conversion type\"\"\"\n\n    regex: str\n\"\"\"The regex to match the conversion type\"\"\"\n    func: ConversionFunc\n\"\"\"The function to convert the matched string to the expected type\"\"\"\n</code></pre>"},{"location":"reference/#reactpy_router.simple.ConversionInfo.func","title":"<code>func: ConversionFunc</code>  <code>instance-attribute</code>","text":"<p>The function to convert the matched string to the expected type</p>"},{"location":"reference/#reactpy_router.simple.ConversionInfo.regex","title":"<code>regex: str</code>  <code>instance-attribute</code>","text":"<p>The regex to match the conversion type</p>"},{"location":"reference/#reactpy_router.simple.SimpleResolver","title":"<code>SimpleResolver</code>","text":"<p>A simple route resolver that uses regex to match paths</p> Source code in <code>reactpy_router/simple.py</code> <pre><code>class SimpleResolver:\n\"\"\"A simple route resolver that uses regex to match paths\"\"\"\n\n    def __init__(self, route: Route) -&gt; None:\n        self.element = route.element\n        self.pattern, self.converters = parse_path(route.path)\n        self.key = self.pattern.pattern\n\n    def resolve(self, path: str) -&gt; tuple[Any, dict[str, Any]] | None:\n        match = self.pattern.match(path)\n        if match:\n            return (\n                self.element,\n                {k: self.converters[k](v) for k, v in match.groupdict().items()},\n            )\n        return None\n</code></pre>"},{"location":"reference/#reactpy_router.types.Route","title":"<code>Route</code>  <code>dataclass</code>","text":"<p>A route that can be matched against a path</p> Source code in <code>reactpy_router/types.py</code> <pre><code>@dataclass(frozen=True)\nclass Route:\n\"\"\"A route that can be matched against a path\"\"\"\n\n    path: str\n\"\"\"The path to match against\"\"\"\n\n    element: Any = field(hash=False)\n\"\"\"The element to render if the path matches\"\"\"\n\n    routes: Sequence[Self]\n\"\"\"Child routes\"\"\"\n\n    def __hash__(self) -&gt; int:\n        el = self.element\n        key = el[\"key\"] if is_vdom(el) and \"key\" in el else getattr(el, \"key\", id(el))\n        return hash((self.path, key, self.routes))\n</code></pre>"},{"location":"reference/#reactpy_router.types.Route.element","title":"<code>element: Any = field(hash=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The element to render if the path matches</p>"},{"location":"reference/#reactpy_router.types.Route.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>The path to match against</p>"},{"location":"reference/#reactpy_router.types.Route.routes","title":"<code>routes: Sequence[Self]</code>  <code>instance-attribute</code>","text":"<p>Child routes</p>"},{"location":"reference/#reactpy_router.types.RouteCompiler","title":"<code>RouteCompiler</code>","text":"<p>             Bases: <code>Protocol[R]</code></p> <p>Compile a route into a resolver that can be matched against a path</p> Source code in <code>reactpy_router/types.py</code> <pre><code>class RouteCompiler(Protocol[R]):\n\"\"\"Compile a route into a resolver that can be matched against a path\"\"\"\n\n    def __call__(self, route: R) -&gt; RouteResolver:\n        ...\n</code></pre>"},{"location":"reference/#reactpy_router.types.RouteResolver","title":"<code>RouteResolver</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>A compiled route that can be matched against a path</p> Source code in <code>reactpy_router/types.py</code> <pre><code>class RouteResolver(Protocol):\n\"\"\"A compiled route that can be matched against a path\"\"\"\n\n    @property\n    def key(self) -&gt; Key:\n\"\"\"Uniquely identified this resolver\"\"\"\n\n    def resolve(self, path: str) -&gt; tuple[Any, dict[str, Any]] | None:\n\"\"\"Return the path's associated element and path params or None\"\"\"\n</code></pre>"},{"location":"reference/#reactpy_router.types.RouteResolver.key","title":"<code>key: Key</code>  <code>property</code>","text":"<p>Uniquely identified this resolver</p>"},{"location":"reference/#reactpy_router.types.RouteResolver.resolve","title":"<code>resolve(path)</code>","text":"<p>Return the path's associated element and path params or None</p> Source code in <code>reactpy_router/types.py</code> <pre><code>def resolve(self, path: str) -&gt; tuple[Any, dict[str, Any]] | None:\n\"\"\"Return the path's associated element and path params or None\"\"\"\n</code></pre>"},{"location":"reference/#reactpy_router.types.Router","title":"<code>Router</code>","text":"<p>             Bases: <code>Protocol[R]</code></p> <p>Return a component that renders the first matching route</p> Source code in <code>reactpy_router/types.py</code> <pre><code>class Router(Protocol[R]):\n\"\"\"Return a component that renders the first matching route\"\"\"\n\n    def __call__(self, *routes: R) -&gt; ComponentType:\n        ...\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Note</p> <p>The sections below assume you already know the basics of ReacPy.</p> <p>Here you'll learn the various features of <code>reactpy-router</code> and how to use them. All examples will utilize the simple.router (though you can use your own).</p>"},{"location":"usage/#routers-and-routes","title":"Routers and Routes","text":"<p>The simple.router component is one possible implementation of a Router. Routers takes a series of Route objects as positional arguments and render whatever element matches the current location. For convenience, these <code>Route</code> objects are created using the route function.</p> <p>Note</p> <p>The current location is determined based on the browser's current URL and can be found by checking the use_location hook.</p> <p>Here's a basic example showing how to use <code>simple.router</code> with two routes:</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import route, simple, use_location\n\n@component\ndef root():\n    location = use_location()\n    return simple.router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n</code></pre> <p>Here we'll note some special syntax in the route path for the second route. The <code>*</code> is a wildcard that will match any path. This is useful for creating a \"404\" page that will be shown when no other route matches.</p>"},{"location":"usage/#simple-router","title":"Simple Router","text":"<p>The syntax for declaring routes with the simple.router is very similar to the syntax used by Starlette (a popular Python web framework). As such route parameters are declared using the following syntax:</p> <pre><code>/my/route/{param}\n/my/route/{param:type}\n</code></pre> <p>In this case, <code>param</code> is the name of the route parameter and the optionally declared <code>type</code> specifies what kind of parameter it is. The available parameter types and what patterns they match are are:</p> <ul> <li>str (default) - <code>[^/]+</code></li> <li>int - <code>\\d+</code></li> <li>float - <code>\\d+(\\.\\d+)?</code></li> <li>uuid - <code>[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}</code></li> <li>path - <code>.+</code></li> </ul> <p>Note</p> <p>The <code>path</code> type is special in that it will match any path, including <code>/</code> characters. This is useful for creating routes that match a path prefix.</p> <p>So in practice these each might look like:</p> <pre><code>/my/route/{param}\n/my/route/{param:int}\n/my/route/{param:float}\n/my/route/{param:uuid}\n/my/route/{param:path}\n</code></pre> <p>Any route parameters collected from the current location then be accessed using the <code>use_params</code> hook.</p> <p>Note</p> <p>It's worth pointing out that, while you can use route parameters to capture values from queryies (i.e. <code>?foo=bar</code>), this is not recommended. Instead, you should use the use_query hook to access query parameters.</p>"},{"location":"usage/#route-links","title":"Route Links","text":"<p>Links between routes should be created using the link component. This will allow ReactPy to handle the transition between routes more quickly by avoiding the cost of a full page load.</p> <pre><code>from reactpy import component, html, run, use_location\nfrom reactpy_router import link, route, simple\n\n@component\ndef root():\n    use_location()\n    return simple.router(\n        route(\n            \"/\",\n            html.div(\n                html.h1(\"Home Page \ud83c\udfe0\"),\n                link(html.button(\"About\"), to=\"/about\"),\n            ),\n        ),\n        route(\"/about\", html.h1(\"About Page \ud83d\udcd6\")),\n    )\n</code></pre>"},{"location":"usage/#hooks","title":"Hooks","text":"<p><code>reactpy-router</code> provides a number of hooks for working with the routes:</p> <ul> <li><code>use_query</code> - for accessing query parameters</li> <li><code>use_params</code> - for accessing route parameters</li> </ul> <p>If you're not familiar with hooks, you should read the docs.</p>"},{"location":"usage/#using-queries","title":"Using Queries","text":"<p>The use_query hook can be used to access query parameters from the current location. It returns a dictionary of query parameters, where each value is a list of strings.</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import link, route, simple, use_query\n\n@component\ndef root():\n    use_location()\n    return simple.router(\n        route(\n            \"/\",\n            html.div(\n                html.h1(\"Home Page \ud83c\udfe0\"),\n                link(\"Search\", to=\"/search?q=reactpy\"),\n            ),\n        ),\n        route(\"/about\", html.h1(\"About Page \ud83d\udcd6\")),\n    )\n\n@component\ndef search():\n    query = use_query()\n    return html.h1(f\"Search Results for {query['q'][0]} \ud83d\udd0d\")\n</code></pre>"},{"location":"usage/#using-parameters","title":"Using Parameters","text":"<p>The use_params hook can be used to access route parameters from the current location. It returns a dictionary of route parameters, where each value is mapped to a value that matches the type specified in the route path.</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import link, route, simple, use_params\n\n@component\ndef root():\n    return simple.router(\n        route(\n            \"/\",\n            html.div(\n                html.h1(\"Home Page \ud83c\udfe0\"),\n                link(\"User 123\", to=\"/user/123\"),\n            ),\n        ),\n        route(\"/user/{id:int}\", user()),\n    )\n\n@component\ndef user():\n    params = use_params()\n    return html.h1(f\"User {params['id']} \ud83d\udc64\")\n</code></pre>"},{"location":"tutorials/custom-router/","title":"Custom Router","text":"<p>Under construction \ud83d\udea7</p>"},{"location":"tutorials/simple-app/","title":"Simple Application","text":"<p>Let's build a simple web application for viewing messages between several people.</p> <p>For the purposes of this tutorial we'll be working with the following data:</p> <pre><code>message_data = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n</code></pre> <p>In a more realistic application this data would be stored in a database, but for this tutorial we'll just keep it in memory.</p>"},{"location":"tutorials/simple-app/#basic-routing","title":"Basic Routing","text":"<p>The first step is to create a basic router that will display the home page when the user navigates to the root of the application, and a \"missing link\" page for any other route:</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import route, simple\n\n@component\ndef root():\n    return simple.router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\nrun(root)\n</code></pre> <p>When navigating to http://127.0.0.1:8000 you should see \"Home Page \ud83c\udfe0\". However, if you go to any other route (e.g. http://127.0.0.1:8000/missing) you will instead see the \"Missing Link \ud83d\udd17\u200d\ud83d\udca5\" page.</p> <p>With this foundation you can start adding more routes:</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import route, simple\n\n@component\ndef root():\n    return simple.router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"/messages\", html.h1(\"Messages \ud83d\udcac\")),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\nrun(root)\n</code></pre> <p>With this change you can now also go to <code>/messages</code> to see \"Messages \ud83d\udcac\" displayed.</p>"},{"location":"tutorials/simple-app/#route-links","title":"Route Links","text":"<p>Instead of using the standard <code>&lt;a&gt;</code> element to create links to different parts of your application, use <code>reactpy_router.link</code> instead. When users click links constructed using <code>reactpy_router.link</code>, instead of letting the browser navigate to the associated route, ReactPy will more quickly handle the transition by avoiding the cost of a full page load.</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import link, route, simple\n\n@component\ndef root():\n    return simple.router(\n        route(\"/\", home()),\n        route(\"/messages\", html.h1(\"Messages \ud83d\udcac\")),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link(\"Messages\", to=\"/messages\"),\n    )\n\nrun(root)\n</code></pre> <p>Now, when you go to the home page, you can click the link to go to <code>/messages</code>.</p>"},{"location":"tutorials/simple-app/#nested-routes","title":"Nested Routes","text":"<p>Routes can be nested in order to construct more complicated application structures:</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import route, simple, link\n\nmessage_data = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n\n@component\ndef root():\n    return simple.router(\n        route(\"/\", home()),\n        route(\n            \"/messages\",\n            all_messages(),\n            # we'll improve upon these manually created routes in the next section...\n            route(\"/with/Alice\", messages_with(\"Alice\")),\n            route(\"/with/Alice-Bob\", messages_with(\"Alice\", \"Bob\")),\n        ),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link(\"Messages\", to=\"/messages\"),\n    )\n\n@component\ndef all_messages():\n    last_messages = {\n        \", \".join(msg[\"with\"]): msg\n        for msg in sorted(message_data, key=lambda m: m[\"id\"])\n    }\n    return html.div(\n        html.h1(\"All Messages \ud83d\udcac\"),\n        html.ul(\n            [\n                html.li(\n                    {\"key\": msg[\"id\"]},\n                    html.p(\n                        link(\n                            f\"Conversation with: {', '.join(msg['with'])}\",\n                            to=f\"/messages/with/{'-'.join(msg['with'])}\",\n                        ),\n                    ),\n                    f\"{'' if msg['from'] is None else '\ud83d\udd34'} {msg['message']}\",\n                )\n                for msg in last_messages.values()\n            ]\n        ),\n    )\n\n@component\ndef messages_with(*names):\n    names = set(names)\n    messages = [msg for msg in message_data if set(msg[\"with\"]) == names]\n    return html.div(\n        html.h1(f\"Messages with {', '.join(names)} \ud83d\udcac\"),\n        html.ul(\n            [\n                html.li(\n                    {\"key\": msg[\"id\"]},\n                    f\"{msg['from'] or 'You'}: {msg['message']}\",\n                )\n                for msg in messages\n            ]\n        ),\n    )\n\nrun(root)\n</code></pre>"},{"location":"tutorials/simple-app/#route-parameters","title":"Route Parameters","text":"<p>In the example above we had to manually create a <code>messages_with(...)</code> component for each conversation. This would be better accomplished by defining a single route that declares \"route parameters\" instead.</p> <p>Any parameters that have matched in the currently displayed route can then be consumed with the <code>use_params</code> hook which returns a dictionary mapping the parameter names to their values. Note that parameters with a declared type will be converted to is in the parameters dictionary. So for example <code>/my/route/{my_param:float}</code> would match <code>/my/route/3.14</code> and have a parameter dictionary of <code>{\"my_param\": 3.14}</code>.</p> <p>If we take this information and apply it to our growing example application we'd substitute the manually constructed <code>/messages/with</code> routes with a single <code>/messages/with/{names}</code> route:</p> <pre><code>from reactpy import component, html, run\nfrom reactpy_router import route, simple, link\nfrom reactpy_router.core import use_params\n\nmessage_data = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n\n@component\ndef root():\n    return simple.router(\n        route(\"/\", home()),\n        route(\n            \"/messages\",\n            all_messages(),\n            route(\"/with/{names}\", messages_with()),  # note the path param\n        ),\n        route(\"*\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link(\"Messages\", to=\"/messages\"),\n    )\n\n@component\ndef all_messages():\n    last_messages = {\n        \", \".join(msg[\"with\"]): msg\n        for msg in sorted(message_data, key=lambda m: m[\"id\"])\n    }\n    return html.div(\n        html.h1(\"All Messages \ud83d\udcac\"),\n        html.ul(\n            [\n                html.li(\n                    {\"key\": msg[\"id\"]},\n                    html.p(\n                        link(\n                            f\"Conversation with: {', '.join(msg['with'])}\",\n                            to=f\"/messages/with/{'-'.join(msg['with'])}\",\n                        ),\n                    ),\n                    f\"{'' if msg['from'] is None else '\ud83d\udd34'} {msg['message']}\",\n                )\n                for msg in last_messages.values()\n            ]\n        ),\n    )\n\n@component\ndef messages_with():\n    names = set(use_params()[\"names\"].split(\"-\"))  # and here we use the path param\n    messages = [msg for msg in message_data if set(msg[\"with\"]) == names]\n    return html.div(\n        html.h1(f\"Messages with {', '.join(names)} \ud83d\udcac\"),\n        html.ul(\n            [\n                html.li(\n                    {\"key\": msg[\"id\"]},\n                    f\"{msg['from'] or 'You'}: {msg['message']}\",\n                )\n                for msg in messages\n            ]\n        ),\n    )\n\nrun(root)\n</code></pre>"}]}