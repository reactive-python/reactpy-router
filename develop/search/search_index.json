{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Add ReactPy-Router to Your Project","text":""},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<p>Run the following command to install <code>reactpy-router</code> in your Python environment.</p> <pre><code>pip install reactpy-router\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>You're now ready to start building your own ReactPy applications with URL routing. For example...</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\nrun(root)\n</code></pre>"},{"location":"about/changelog/","title":"Changelog","text":"<p>    The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.    </p>"},{"location":"about/changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Nothing (yet)!</li> </ul>"},{"location":"about/changelog/#102-2024-10-24","title":"1.0.2 - 2024-10-24","text":""},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix python <code>wheel</code> missing <code>bundle.js</code> file.</li> </ul>"},{"location":"about/changelog/#101-2024-10-24","title":"1.0.1 - 2024-10-24","text":""},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>JavaScript bundle is now created using <code>Bun</code>.</li> <li>Python package is now built using <code>Hatch</code>.</li> </ul>"},{"location":"about/changelog/#100-2024-10-18","title":"1.0.0 - 2024-10-18","text":""},{"location":"about/changelog/#changed_1","title":"Changed","text":"<ul> <li>Rename <code>use_query</code> to <code>use_search_params</code>.</li> <li>Rename <code>simple.router</code> to <code>browser_router</code>.</li> <li>Rename <code>SimpleResolver</code> to <code>StarletteResolver</code>.</li> <li>Rename <code>CONVERSION_TYPES</code> to <code>CONVERTERS</code>.</li> <li>Change \"Match Any\" syntax from a star <code>*</code> to <code>{name:any}</code>.</li> <li>Rewrite <code>reactpy_router.link</code> to be a server-side component.</li> <li>Simplified top-level exports that are available within <code>reactpy_router.*</code>.</li> </ul>"},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Add debug log message for when there are no router matches.</li> <li>Add slug as a supported type.</li> <li>Add <code>reactpy_router.navigate</code> component that will force the client to navigate to a new URL (when rendered).</li> <li>New error for ReactPy router elements being used outside router context.</li> <li>Configurable/inheritable <code>Resolver</code> base class.</li> </ul>"},{"location":"about/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix bug where changing routes could cause render failure due to key identity.</li> <li>Fix bug where \"Match Any\" pattern wouldn't work when used in complex or nested paths.</li> <li>Fix bug where <code>link</code> elements could not have <code>@component</code> type children.</li> <li>Fix bug where the ReactPy would not detect the current URL after a reconnection.</li> <li>Fix bug where <code>ctrl</code> + <code>click</code> on a <code>link</code> element would not open in a new tab.</li> <li>Fix test suite on Windows machines.</li> </ul>"},{"location":"about/changelog/#011-2023-12-13","title":"0.1.1 - 2023-12-13","text":""},{"location":"about/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed relative navigation.</li> </ul>"},{"location":"about/changelog/#010-2023-06-16","title":"0.1.0 - 2023-06-16","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li>Automatically handle client-side history changes.</li> </ul>"},{"location":"about/changelog/#001-2023-05-10","title":"0.0.1 - 2023-05-10","text":""},{"location":"about/changelog/#added_2","title":"Added","text":"<ul> <li>Add robust lint/testing.</li> <li>Upgrade <code>reactpy</code>.</li> <li>More robust routing with <code>starlette</code>.</li> <li>Initial draft of router compiler.</li> </ul>"},{"location":"about/changelog/#changed_2","title":"Changed","text":"<ul> <li>Rename <code>configure</code> to <code>create_router</code>.</li> <li>Rename from <code>idom-router</code> to <code>reactpy-router</code>.</li> </ul>"},{"location":"about/contributing/","title":"Contributor Guide","text":""},{"location":"about/contributing/#creating-a-development-environment","title":"Creating a development environment","text":"<p>If you plan to make code changes to this repository, you will need to install the following dependencies first:</p> <ul> <li>Git</li> <li>Python 3.9+</li> <li>Hatch</li> </ul> <p>Once you finish installing these dependencies, you can clone this repository:</p> <pre><code>git clone https://github.com/reactive-python/reactpy-router.git\ncd reactpy-router\n</code></pre>"},{"location":"about/contributing/#executing-test-environment-commands","title":"Executing test environment commands","text":"<p>By utilizing <code>hatch</code>, the following commands are available to manage the development environment.</p>"},{"location":"about/contributing/#tests","title":"Tests","text":"Command Description <code>hatch test</code> Run Python tests using the current environment's Python version <code>hatch test --all</code> Run tests using all compatible Python versions <code>hatch test --python 3.9</code> Run tests using a specific Python version <code>hatch test -k test_navigate_with_link</code> Run only a specific test What other arguments are available to me? <p>The <code>hatch test</code> command is a wrapper for <code>pytest</code>. Hatch \"intercepts\" a handful of arguments, which can be previewed by typing <code>hatch test --help</code>.</p> <p>Any additional arguments in the <code>test</code> command are directly passed on to pytest. See the pytest documentation for what additional arguments are available.</p>"},{"location":"about/contributing/#linting-and-formatting","title":"Linting and Formatting","text":"Command Description <code>hatch fmt</code> Run all linters and formatters <code>hatch fmt --check</code> Run all linters and formatters, but do not save fixes to the disk <code>hatch fmt --linter</code> Run only linters <code>hatch fmt --formatter</code> Run only formatters Configure your IDE for linting <p>This repository uses <code>hatch fmt</code> for linting and formatting, which is a modestly customized version of <code>ruff</code>.</p> <p>You can install <code>ruff</code> as a plugin to your preferred code editor to create a similar environment.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"Command Description <code>hatch run docs:serve</code> Start the <code>mkdocs</code> server to view documentation locally <code>hatch run docs:build</code> Build the documentation <code>hatch run docs:linkcheck</code> Check for broken links in the documentation"},{"location":"about/contributing/#environment-management","title":"Environment Management","text":"Command Description <code>hatch build --clean</code> Build the package from source <code>hatch env prune</code> Delete all virtual environments created by <code>hatch</code> <code>hatch python install 3.12</code> Install a specific Python version to your system Check out Hatch for all available commands! <p>This documentation only covers commonly used commands.</p> <p>You can type <code>hatch --help</code> to see all available commands.</p>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#the-mit-license-mit","title":"The MIT License (MIT)","text":""},{"location":"about/license/#copyright-c-reactive-python-and-affiliates","title":"Copyright (c) Reactive Python and affiliates.","text":"<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"learn/custom-router/","title":"Custom Router","text":"<p>Under construction \ud83d\udea7</p>"},{"location":"learn/hooks/","title":"Hooks","text":"<p>Several pre-fabricated hooks are provided to help integrate with routing features. You can learn more about them below.</p> <p>Note</p> <p>If you're not familiar what a hook is, you should read the ReactPy docs.</p>"},{"location":"learn/hooks/#use-search-parameters","title":"Use Search Parameters","text":"<p>The <code>use_search_params</code> hook can be used to access query parameters from the current location. It returns a dictionary of query parameters, where each value is a list of strings.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route, use_search_params\n\n\n@component\ndef search():\n    search_params = use_search_params()\n    return html._(html.h1(f\"Search Results for {search_params['query'][0]} \ud83d\udd0d\"), html.p(\"Nothing (yet).\"))\n\n\n@component\ndef root():\n    return browser_router(\n        route(\n            \"/\",\n            html.div(\n                html.h1(\"Home Page \ud83c\udfe0\"),\n                link({\"to\": \"/search?query=reactpy\"}, \"Search\"),\n            ),\n        ),\n        route(\"/search\", search()),\n    )\n\n\nrun(root)\n</code></pre>"},{"location":"learn/hooks/#use-parameters","title":"Use Parameters","text":"<p>The <code>use_params</code> hook can be used to access route parameters from the current location. It returns a dictionary of route parameters, where each value is mapped to a value that matches the type specified in the route path.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route, use_params\n\n\n@component\ndef user():\n    params = use_params()\n    return html._(html.h1(f\"User {params['id']} \ud83d\udc64\"), html.p(\"Nothing (yet).\"))\n\n\n@component\ndef root():\n    return browser_router(\n        route(\n            \"/\",\n            html.div(\n                html.h1(\"Home Page \ud83c\udfe0\"),\n                link({\"to\": \"/user/123\"}, \"User 123\"),\n            ),\n        ),\n        route(\"/user/{id:int}\", user()),\n    )\n\n\nrun(root)\n</code></pre>"},{"location":"learn/routers-routes-and-links/","title":"Routers, Routes, and Links","text":"<p>We include built-in components that automatically handle routing, which enable Single Page Application (SPA) behavior.</p>"},{"location":"learn/routers-routes-and-links/#routers-and-routes","title":"Routers and Routes","text":"<p>The <code>browser_router</code> component is one possible implementation of a Router. Routers takes a series of route objects as positional arguments and render whatever element matches the current location.</p> <p>Note</p> <p>The current location is determined based on the browser's current URL and can be found by checking the <code>use_location</code> hook.</p> <p>Here's a basic example showing how to use <code>browser_router</code> with two routes.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\nrun(root)\n</code></pre> <p>Here we'll note some special syntax in the route path for the second route. The <code>\"any\"</code> type is a wildcard that will match any path. This is useful for creating a default page or error page such as \"404 NOT FOUND\".</p>"},{"location":"learn/routers-routes-and-links/#browser-router","title":"Browser Router","text":"<p>The syntax for declaring routes with the <code>browser_router</code> is very similar to the syntax used by <code>starlette</code> (a popular Python web framework). As such route parameters are declared using the following syntax:</p> <pre><code>/my/route/{param}\n/my/route/{param:type}\n</code></pre> <p>In this case, <code>param</code> is the name of the route parameter and the optionally declared <code>type</code> specifies what kind of parameter it is. The available parameter types and what patterns they match are are:</p> Type Pattern <code>str</code> (default) <code>[^/]+</code> <code>int</code> <code>\\d+</code> <code>float</code> <code>\\d+(\\.\\d+)?</code> <code>uuid</code> <code>[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}</code> <code>slug</code> <code>[-a-zA-Z0-9_]+</code> <code>path</code> <code>.+</code> <code>any</code> <code>.*</code> <p>So in practice these each might look like:</p> <pre><code>/my/route/{param}\n/my/route/{param:int}\n/my/route/{param:float}\n/my/route/{param:uuid}\n/my/route/{param:path}\n</code></pre> <p>Any route parameters collected from the current location then be accessed using the <code>use_params</code> hook.</p> <p>Pitfall</p> <p>While it is possible to use route parameters to capture values from query strings (such as <code>/my/route/?foo={bar}</code>), this is not recommended. Instead, you should use the <code>use_search_params</code> hook to access query string values.</p>"},{"location":"learn/routers-routes-and-links/#route-links","title":"Route Links","text":"<p>Links between routes should be created using the link component. This will allow ReactPy to handle the transition between routes and avoid a page reload.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", home()),\n        route(\"/messages\", html.h1(\"Messages \ud83d\udcac\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link({\"to\": \"/messages\"}, \"Messages\"),\n    )\n\n\nrun(root)\n</code></pre>"},{"location":"learn/your-first-app/","title":"Your First Routed Application","text":"<p>  Here you'll learn the various features of <code>reactpy-router</code> and how to use them. These examples will utilize the <code>reactpy_router.browser_router</code>.  </p> <p>Note</p> <p>These docs assume you already know the basics of ReactPy.</p> <p>Let's build a simple web application for viewing messages between several people.</p> <p>For the purposes of this tutorial we'll be working with the following data.</p> <pre><code>message_data = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n</code></pre> <p>In a more realistic application this data would be stored in a database, but for this tutorial we'll just keep it in memory.</p>"},{"location":"learn/your-first-app/#creating-basic-routes","title":"Creating Basic Routes","text":"<p>The first step is to create a basic router that will display the home page when the user navigates to the root of the application, and a \"missing link\" page for any other route.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\nrun(root)\n</code></pre> <p>When navigating to <code>http://127.0.0.1:8000</code> you should see <code>Home Page \ud83c\udfe0</code>. However, if you go to any other route you will instead see <code>Missing Link \ud83d\udd17\u200d\ud83d\udca5</code>.</p> <p>With this foundation you can start adding more routes.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", html.h1(\"Home Page \ud83c\udfe0\")),\n        route(\"/messages\", html.h1(\"Messages \ud83d\udcac\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\nrun(root)\n</code></pre> <p>With this change you can now also go to <code>/messages</code> to see <code>Messages \ud83d\udcac</code>.</p>"},{"location":"learn/your-first-app/#using-route-links","title":"Using Route Links","text":"<p>Instead of using the standard <code>reactpy.html.a</code> element to create links to different parts of your application, use <code>reactpy_router.link</code> instead. When users click links constructed using <code>reactpy_router.link</code>, ReactPy will handle the transition and prevent a full page reload.</p> components.py <pre><code>from reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", home()),\n        route(\"/messages\", html.h1(\"Messages \ud83d\udcac\")),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link({\"to\": \"/messages\"}, \"Messages\"),\n    )\n\n\nrun(root)\n</code></pre> <p>Now, when you go to the home page, you can click <code>Messages</code> link to go to <code>/messages</code>.</p>"},{"location":"learn/your-first-app/#adding-nested-routes","title":"Adding Nested Routes","text":"<p>Routes can be nested in order to construct more complicated application structures.</p> components.py <pre><code>import operator\nfrom typing import TypedDict\n\nfrom reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route\n\nmessage_data: list[\"MessageDataType\"] = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", home()),\n        route(\n            \"/messages\",\n            all_messages(),\n            # we'll improve upon these manually created routes in the next section...\n            route(\"/with/Alice\", messages_with(\"Alice\")),\n            route(\"/with/Alice-Bob\", messages_with(\"Alice\", \"Bob\")),\n        ),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link({\"to\": \"/messages\"}, \"Messages\"),\n    )\n\n\n@component\ndef all_messages():\n    last_messages = {\", \".join(msg[\"with\"]): msg for msg in sorted(message_data, key=operator.itemgetter(\"id\"))}\n\n    messages = []\n    for msg in last_messages.values():\n        _link = link(\n            {\"to\": f\"/messages/with/{'-'.join(msg['with'])}\"},\n            f\"Conversation with: {', '.join(msg['with'])}\",\n        )\n        msg_from = f\"{'' if msg['from'] is None else '\ud83d\udd34'} {msg['message']}\"\n        messages.append(html.li({\"key\": msg[\"id\"]}, html.p(_link), msg_from))\n\n    return html.div(\n        html.h1(\"All Messages \ud83d\udcac\"),\n        html.ul(messages),\n    )\n\n\n@component\ndef messages_with(*names):\n    messages = [msg for msg in message_data if tuple(msg[\"with\"]) == names]\n    return html.div(\n        html.h1(f\"Messages with {', '.join(names)} \ud83d\udcac\"),\n        html.ul([\n            html.li(\n                {\"key\": msg[\"id\"]},\n                f\"{msg['from'] or 'You'}: {msg['message']}\",\n            )\n            for msg in messages\n        ]),\n    )\n\n\nrun(root)\n\nMessageDataType = TypedDict(\n    \"MessageDataType\",\n    {\"id\": int, \"with\": list[str], \"from\": str | None, \"message\": str},\n)\n</code></pre>"},{"location":"learn/your-first-app/#adding-route-parameters","title":"Adding Route Parameters","text":"<p>In the example above we had to manually create a <code>messages_with(...)</code> component for each conversation. This would be better accomplished by defining a single route that declares route parameters instead.</p> <p>Any parameters that have matched in the currently displayed route can then be consumed with the <code>use_params</code> hook which returns a dictionary mapping the parameter names to their values. Note that parameters with a declared type will be converted to is in the parameters dictionary. So for example <code>/my/route/{my_param:float}</code> would match <code>/my/route/3.14</code> and have a parameter dictionary of <code>{\"my_param\": 3.14}</code>.</p> <p>If we take this information and apply it to our growing example application we'd substitute the manually constructed <code>/messages/with</code> routes with a single <code>/messages/with/{names}</code> route.</p> components.py <pre><code>import operator\nfrom typing import TypedDict\n\nfrom reactpy import component, html, run\n\nfrom reactpy_router import browser_router, link, route, use_params\n\nmessage_data: list[\"MessageDataType\"] = [\n    {\"id\": 1, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Hello!\"},\n    {\"id\": 2, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"How's it going?\"},\n    {\"id\": 3, \"with\": [\"Alice\"], \"from\": None, \"message\": \"Good, you?\"},\n    {\"id\": 4, \"with\": [\"Alice\"], \"from\": \"Alice\", \"message\": \"Good, thanks!\"},\n    {\"id\": 5, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"We meeting now?\"},\n    {\"id\": 6, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Alice\", \"message\": \"Not sure.\"},\n    {\"id\": 7, \"with\": [\"Alice\", \"Bob\"], \"from\": \"Bob\", \"message\": \"I'm here!\"},\n    {\"id\": 8, \"with\": [\"Alice\", \"Bob\"], \"from\": None, \"message\": \"Great!\"},\n]\n\n\n@component\ndef root():\n    return browser_router(\n        route(\"/\", home()),\n        route(\n            \"/messages\",\n            all_messages(),\n            route(\"/with/{names}\", messages_with()),  # note the path param\n        ),\n        route(\"{404:any}\", html.h1(\"Missing Link \ud83d\udd17\u200d\ud83d\udca5\")),\n    )\n\n\n@component\ndef home():\n    return html.div(\n        html.h1(\"Home Page \ud83c\udfe0\"),\n        link({\"to\": \"/messages\"}, \"Messages\"),\n    )\n\n\n@component\ndef all_messages():\n    last_messages = {\", \".join(msg[\"with\"]): msg for msg in sorted(message_data, key=operator.itemgetter(\"id\"))}\n    messages = []\n    for msg in last_messages.values():\n        msg_hyperlink = link(\n            {\"to\": f\"/messages/with/{'-'.join(msg['with'])}\"},\n            f\"Conversation with: {', '.join(msg['with'])}\",\n        )\n        msg_from = f\"{'' if msg['from'] is None else '\ud83d\udd34'} {msg['message']}\"\n        messages.append(html.li({\"key\": msg[\"id\"]}, html.p(msg_hyperlink), msg_from))\n\n    return html.div(\n        html.h1(\"All Messages \ud83d\udcac\"),\n        html.ul(messages),\n    )\n\n\n@component\ndef messages_with():\n    names = tuple(use_params()[\"names\"].split(\"-\"))  # and here we use the path param\n    messages = [msg for msg in message_data if tuple(msg[\"with\"]) == names]\n    return html.div(\n        html.h1(f\"Messages with {', '.join(names)} \ud83d\udcac\"),\n        html.ul([\n            html.li(\n                {\"key\": msg[\"id\"]},\n                f\"{msg['from'] or 'You'}: {msg['message']}\",\n            )\n            for msg in messages\n        ]),\n    )\n\n\nrun(root)\n\nMessageDataType = TypedDict(\n    \"MessageDataType\",\n    {\"id\": int, \"with\": list[str], \"from\": str | None, \"message\": str},\n)\n</code></pre>"},{"location":"reference/components/","title":"Components","text":""},{"location":"reference/components/#reactpy_router.route","title":"<code>reactpy_router.route(path, element, *routes)</code>","text":"<p>Create a route with the given path, element, and child routes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path for the route.</p> required <code>element</code> <code>Any | None</code> <p>The element to render for this route. Can be None.</p> required <code>routes</code> <code>Route</code> <p>Additional child routes.</p> <code>()</code> <p>Returns:</p> Type Description <code>Route</code> <p>The created route object.</p>"},{"location":"reference/components/#reactpy_router.link","title":"<code>reactpy_router.link(attributes, *children, key=None)</code>","text":"<p>Create a link with the given attributes and children.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>dict[str, Any]</code> <p>A dictionary of attributes for the link.</p> required <code>*children</code> <code>Any</code> <p>Child elements to be included within the link.</p> <code>()</code> <p>Returns:</p> Type Description <code>Component</code> <p>A link component with the specified attributes and children.</p>"},{"location":"reference/components/#reactpy_router.navigate","title":"<code>reactpy_router.navigate(to, replace=False, key=None)</code>","text":"<p>Navigate to a specified URL.</p> <p>This function changes the browser's current URL when it is rendered.</p> <p>Parameters:</p> Name Type Description Default <code>to</code> <code>str</code> <p>The target URL to navigate to.</p> required <code>replace</code> <code>bool</code> <p>If True, the current history entry will be replaced             with the new URL. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Component</code> <p>The component responsible for navigation.</p>"},{"location":"reference/hooks/","title":"Hooks","text":""},{"location":"reference/hooks/#reactpy_router.use_params","title":"<code>reactpy_router.use_params()</code>","text":"<p>This hook returns an object of key/value pairs of the dynamic parameters     from the current URL that were matched by the <code>Route</code>. Child routes inherit all parameters     from their parent routes.</p> <p>For example, if you have a <code>URL_PARAM</code> defined in the route <code>/example/&lt;URL_PARAM&gt;/</code>, this hook will return the <code>URL_PARAM</code> value that was matched.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary of the current URL's parameters.</p>"},{"location":"reference/hooks/#reactpy_router.use_search_params","title":"<code>reactpy_router.use_search_params(keep_blank_values=False, strict_parsing=False, errors='replace', max_num_fields=None, separator='&amp;')</code>","text":"<p>This hook is used to read the query string in the URL for the current location.</p> <p>See <code>urllib.parse.parse_qs</code>         for info on this hook's parameters.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>A dictionary of the current URL's query string parameters.</p>"},{"location":"reference/routers/","title":"Routers","text":""},{"location":"reference/routers/#reactpy_router.browser_router","title":"<code>reactpy_router.browser_router(*routes)</code>","text":"<p>This is the recommended router for all ReactPy-Router web projects. It uses the JavaScript History API to manage the history stack.</p> <p>Parameters:</p> Name Type Description Default <code>*routes</code> <code>RouteType</code> <p>A list of routes to be rendered by the router.</p> <code>()</code> <p>Returns:</p> Type Description <code>Component</code> <p>A router component that renders the given routes.</p>"},{"location":"reference/types/","title":"Types","text":"<p>Type definitions for the <code>reactpy-router</code> package.</p> <p>Classes:</p> <ul> <li> <code>CompiledRoute</code>           \u2013            <p>A protocol for a compiled route that can be matched against a path.</p> </li> <li> <code>ConversionInfo</code>           \u2013            <p>A TypedDict that holds information about a conversion type.</p> </li> <li> <code>Resolver</code>           \u2013            <p>Compile a route into a resolver that can be matched against a given path.</p> </li> <li> <code>Route</code>           \u2013            <p>A class representing a route that can be matched against a path.</p> </li> <li> <code>RouteState</code>           \u2013            <p>Represents the state of a route in the application.</p> </li> <li> <code>Router</code>           \u2013            <p>Return a component that renders the matching route(s).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>ConversionFunc</code>               (<code>TypeAlias</code>)           \u2013            <p>A function that converts a string to a specific type.</p> </li> <li> <code>ConverterMapping</code>               (<code>TypeAlias</code>)           \u2013            <p>A mapping of conversion types to their respective functions.</p> </li> <li> <code>RouteType</code>           \u2013            <p>A type variable for <code>Route</code>.</p> </li> <li> <code>RouteType_contra</code>           \u2013            <p>A contravariant type variable for <code>Route</code>.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.ConversionFunc","title":"<code>reactpy_router.types.ConversionFunc: TypeAlias = Callable[[str], Any]</code>","text":"<p>A function that converts a string to a specific type.</p>"},{"location":"reference/types/#reactpy_router.types.ConverterMapping","title":"<code>reactpy_router.types.ConverterMapping: TypeAlias = dict[str, ConversionFunc]</code>","text":"<p>A mapping of conversion types to their respective functions.</p>"},{"location":"reference/types/#reactpy_router.types.RouteType","title":"<code>reactpy_router.types.RouteType = TypeVar('RouteType', bound=Route)</code>","text":"<p>A type variable for <code>Route</code>.</p>"},{"location":"reference/types/#reactpy_router.types.RouteType_contra","title":"<code>reactpy_router.types.RouteType_contra = TypeVar('RouteType_contra', bound=Route, contravariant=True)</code>","text":"<p>A contravariant type variable for <code>Route</code>.</p>"},{"location":"reference/types/#reactpy_router.types.CompiledRoute","title":"<code>reactpy_router.types.CompiledRoute</code>","text":"<p>A protocol for a compiled route that can be matched against a path.</p> <p>Attributes:</p> <ul> <li> <code>key</code>               (<code>Key</code>)           \u2013            <p>A property that uniquely identifies this resolver.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>resolve</code>             \u2013              <p>Return the path's associated element and path parameters or None.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.CompiledRoute.resolve","title":"<code>reactpy_router.types.CompiledRoute.resolve(path)</code>","text":"<p>Return the path's associated element and path parameters or None.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to resolve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Any, dict[str, Any]] | None</code>           \u2013            <p>A tuple containing the associated element and a dictionary of path parameters, or None if the path cannot be resolved.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.ConversionInfo","title":"<code>reactpy_router.types.ConversionInfo</code>","text":"<p>A TypedDict that holds information about a conversion type.</p> <p>Attributes:</p> <ul> <li> <code>regex</code>               (<code>str</code>)           \u2013            <p>The regex to match the conversion type.</p> </li> <li> <code>func</code>               (<code>ConversionFunc</code>)           \u2013            <p>The function to convert the matched string to the expected type.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.Resolver","title":"<code>reactpy_router.types.Resolver</code>","text":"<p>Compile a route into a resolver that can be matched against a given path.</p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              <p>Compile a route into a resolver that can be matched against a given path.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.Resolver.__call__","title":"<code>reactpy_router.types.Resolver.__call__(route)</code>","text":"<p>Compile a route into a resolver that can be matched against a given path.</p> <p>Parameters:</p> <ul> <li> <code>route</code>               (<code>RouteType_contra</code>)           \u2013            <p>The route to compile.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CompiledRoute</code>           \u2013            <p>The compiled route.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.Route","title":"<code>reactpy_router.types.Route</code>","text":"<p>A class representing a route that can be matched against a path.</p> <p>Attributes:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to match against.</p> </li> <li> <code>element</code>               (<code>Any</code>)           \u2013            <p>The element to render if the path matches.</p> </li> <li> <code>routes</code>               (<code>Sequence[Self]</code>)           \u2013            <p>Child routes.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__hash__</code>             \u2013              <p>Returns a hash value for the route based on its path, element, and child routes.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.RouteState","title":"<code>reactpy_router.types.RouteState</code>","text":"<p>Represents the state of a route in the application.</p> <p>Attributes:</p> <ul> <li> <code>set_location</code>               (<code>Callable[[Location], None]</code>)           \u2013            <p>A callable to set the location.</p> </li> <li> <code>params</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A dictionary containing route parameters.</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.Router","title":"<code>reactpy_router.types.Router</code>","text":"<p>Return a component that renders the matching route(s).</p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              <p>Process the given routes and return a component that renders the matching route(s).</p> </li> </ul>"},{"location":"reference/types/#reactpy_router.types.Router.__call__","title":"<code>reactpy_router.types.Router.__call__(*routes)</code>","text":"<p>Process the given routes and return a component that renders the matching route(s).</p> <p>Parameters:</p> <ul> <li> <code>*routes</code>               (<code>RouteType_contra</code>, default:                   <code>()</code> )           \u2013            <p>A variable number of route arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Component</code>           \u2013            <p>The resulting component after processing the routes.</p> </li> </ul>"}]}